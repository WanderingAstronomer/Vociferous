#!/usr/bin/env python3
"""
Vociferous - Application Entry Point.

This is the bootstrap script that sets up the environment and launches
the main application. It handles GPU library paths before any CUDA
libraries are loaded.

Why a Separate Entry Point?
---------------------------
The main application is in `src/main.py`, but we need this script to:
1. Configure LD_LIBRARY_PATH for GPU libraries
2. Set up Python path to find `src/` modules
3. Configure logging before any other code runs

The key insight is that LD_LIBRARY_PATH must be set BEFORE the process
loads any CUDA/cuDNN libraries. Setting it after import won't work.

Process Re-execution Pattern:
-----------------------------
```
┌─────────────────────────────────────────────────────────────────┐
│  First Execution (LD_LIBRARY_PATH not set)                      │
├─────────────────────────────────────────────────────────────────┤
│  1. Check if NVIDIA libs exist in venv                          │
│  2. Set LD_LIBRARY_PATH with cuDNN + cuBLAS paths               │
│  3. Set sentinel env var _VOCIFEROUS_ENV_READY=1                │
│  4. os.execv() → replaces process with new instance             │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  Second Execution (LD_LIBRARY_PATH set, sentinel present)       │
├─────────────────────────────────────────────────────────────────┤
│  1. Check sentinel → skip re-exec                               │
│  2. Import main (loads CUDA with correct paths)                 │
│  3. Run application                                             │
└─────────────────────────────────────────────────────────────────┘
```

The sentinel prevents infinite re-execution loops.

os.execv() vs subprocess:
-------------------------
`os.execv(executable, args)` REPLACES the current process entirely.
The PID stays the same, but the code is different. This is cleaner
than spawning a subprocess:
- No parent process to manage
- Same PID (for process managers)
- No IPC needed

Path Discovery:
---------------
```python
python_dirs = list(lib_path.glob('python3.*'))
site_packages = python_dirs[0] / 'site-packages' / 'nvidia'
```

NVIDIA installs CUDA libraries into the venv's site-packages. We use
glob to find the Python version directory (3.11, 3.12, etc.) without
hardcoding it.

Why setdefault for CUDA_VISIBLE_DEVICES?
----------------------------------------
```python
os.environ.setdefault('CUDA_VISIBLE_DEVICES', '0')
```

setdefault only sets if not already set. This lets users override
which GPU to use via environment variable while providing a sensible
default (first GPU).

Logging Configuration:
----------------------
Configured BEFORE imports to catch early log messages. Format includes
time, level, logger name, and message for debugging.

Python 3.12+ Features:
----------------------
- Pathlib throughout (no os.path)
- f-strings for path concatenation
- Unpacking in function calls (`*sys.argv`)
"""

import logging
import os
import sys
from pathlib import Path
from importlib.util import find_spec


def _configure_logging() -> None:
    """
    Configure application-wide logging.

    Called before any other code to ensure all log messages are captured.
    Uses a simple console format suitable for development and debugging.

    Format: "HH:MM:SS | LEVEL | logger.name | message"
    """
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
        datefmt="%H:%M:%S",
    )


def _check_python_version() -> None:
    """
    Verify Python 3.12+ is being used.

    Fails fast with a clear error if the Python version is insufficient.
    This prevents cryptic import errors later.
    """
    if sys.version_info < (3, 12):
        logger = logging.getLogger("Vociferous")
        logger.error(
            f"Python 3.12+ required, but running Python {sys.version_info.major}.{sys.version_info.minor}. "
            f"Please use Python 3.12 or later."
        )
        sys.exit(1)


def _validate_dependencies() -> None:
    """
    Check that critical dependencies are installed.

    Validates key packages (PyQt6, sqlalchemy) that will be imported.
    Provides clear guidance if dependencies are missing.
    """
    logger = logging.getLogger("Vociferous")
    required_modules = [
        "PyQt6",
        "sqlalchemy",
        "faster_whisper",
    ]

    missing = []
    for module in required_modules:
        if find_spec(module) is None:
            missing.append(module)

    if missing:
        logger.error(
            f"Missing required dependencies: {', '.join(missing)}. "
            f"Please install dependencies:\n"
            f"  source .venv/bin/activate\n"
            f"  pip install -r requirements.txt\n"
            f"Or run: bash scripts/install.sh"
        )
        sys.exit(1)


def _preflight_env() -> None:
    """
    Preflight environment setup for GPU acceleration.

    This function ensures CUDA libraries are discoverable by the dynamic
    linker before any Python code imports them. On Linux, LD_LIBRARY_PATH
    must be set before process start, hence the re-exec pattern.

    The function:
    1. Checks if we've already run (sentinel variable)
    2. Locates NVIDIA CUDA libraries in the venv
    3. If found and not in LD_LIBRARY_PATH, re-execs with correct paths
    4. Sets CUDA_VISIBLE_DEVICES to ensure GPU is available

    Sentinel Pattern:
    -----------------
    `_VOCIFEROUS_ENV_READY` prevents infinite recursion. Without it:
    - Script runs, sets LD_LIBRARY_PATH, execs
    - New process runs, sets LD_LIBRARY_PATH, execs
    - ...forever
    """
    logger = logging.getLogger("Vociferous")

    # 1. Enforce Virtual Environment
    # If the venv exists, we MUST use it. This prevents ModuleNotFoundError
    # when dependencies (like sqlalchemy) are installed in venv but script
    # runs via system python.
    venv_path = Path(__file__).parent / ".venv"
    venv_python = venv_path / "bin" / "python3"

    if venv_python.exists():
        # Enforce Venv by checking sys.prefix
        # If we are in the venv, sys.prefix should resolve to the venv directory.
        # If we are in system python, it will be /usr or similar.
        try:
            current_prefix = Path(sys.prefix).resolve()
            expected_prefix = venv_path.resolve()

            if current_prefix != expected_prefix:
                # Re-exec args: [python, script, *args]
                try:
                    os.execv(str(venv_python), [str(venv_python), *sys.argv])
                except OSError as e:
                    logger.error(
                        f"Failed to re-execute with venv Python: {e}. "
                        f"Please activate manually: source .venv/bin/activate"
                    )
                    sys.exit(1)
        except Exception as e:
            logger.warning(f"Could not enforce venv: {e}. Proceeding with current Python.")
    else:
        logger.warning(
            "Virtual environment not found at .venv/. "
            "Run: bash scripts/install.sh"
        )

    # Sentinel to prevent infinite re-exec loop
    if os.environ.get("_VOCIFEROUS_ENV_READY") == "1":
        return

    # venv lives at project root (same directory as this script)
    # Find Python version dynamically
    lib_path = venv_path / "lib"
    if not lib_path.exists():
        return

    python_dirs = list(lib_path.glob("python3.*"))
    if not python_dirs:
        return

    site_packages = python_dirs[0] / "site-packages" / "nvidia"
    cudnn_lib = site_packages / "cudnn" / "lib"
    cublas_lib = site_packages / "cublas" / "lib"

    if cudnn_lib.exists() and cublas_lib.exists():
        ld_path = os.environ.get("LD_LIBRARY_PATH", "")
        cudnn_str, cublas_str = str(cudnn_lib), str(cublas_lib)

        if cudnn_str not in ld_path or cublas_str not in ld_path:
            # Re-exec with correct LD_LIBRARY_PATH (must be set before process starts)
            os.environ["LD_LIBRARY_PATH"] = f"{cudnn_str}:{cublas_str}:{ld_path}"
            os.environ["_VOCIFEROUS_ENV_READY"] = "1"
            try:
                os.execv(sys.executable, [sys.executable, *sys.argv])
            except OSError as e:
                logger.error(f"Failed to re-exec with GPU libraries: {e}")
                sys.exit(1)
    else:
        logger.debug("NVIDIA GPU libraries not found, proceeding without GPU acceleration")

    # Hint CUDA visibility
    os.environ.setdefault("CUDA_VISIBLE_DEVICES", "0")


def _configure_qt_logging_rules() -> None:
    """Set Qt logging rules to quiet expected warnings."""
    rules = os.environ.get("QT_LOGGING_RULES", "")
    desired = [
        "qt.qpa.wayland=false",  # already present to reduce Wayland noise
        "qt.core.io.fs.watchers.warning=false",  # silence QFileSystemWatcher empties
        "qt.qpa.tray=false",  # silence all D-Bus tray icon messages
        "dbus.integration=false",  # silence D-Bus integration warnings
    ]

    for rule in desired:
        if rule not in rules.split(";"):
            rules = f"{rules};{rule}" if rules else rule

    os.environ["QT_LOGGING_RULES"] = rules


class _StderrFilter:
    """Filter stderr to suppress known Qt D-Bus noise."""

    def __init__(self, stream):
        self._stream = stream
        self._suppress_patterns = [
            "QDBusTrayIcon",
            "org.freedesktop.DBus.Error",
        ]

    def write(self, text):
        if not any(pattern in text for pattern in self._suppress_patterns):
            self._stream.write(text)

    def flush(self):
        self._stream.flush()

    def fileno(self):
        return self._stream.fileno()


# Add src to path (src is in the project root, same directory as this script)
sys.path.insert(0, str(Path(__file__).parent / "src"))

if __name__ == "__main__":
    _configure_logging()
    logger = logging.getLogger("Vociferous")

    # Validation: Check Python version
    _check_python_version()

    # Validation: Check that src/main.py exists
    main_file = Path(__file__).parent / "src" / "main.py"
    if not main_file.exists():
        logger.error(
            f"Application entry point not found: {main_file}. "
            f"This may indicate a corrupted installation."
        )
        sys.exit(1)

    # Environment setup
    _preflight_env()

    # Validation: Check dependencies after environment setup
    _validate_dependencies()

    # Startup diagnostics
    logger.info(f"Python {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}")
    logger.info(f"Virtual environment: {Path(sys.prefix).name}")
    gpu_devices = os.environ.get("CUDA_VISIBLE_DEVICES", "None")
    logger.info(f"GPU (CUDA_VISIBLE_DEVICES): {gpu_devices}")

    # Configure Qt logging
    _configure_qt_logging_rules()

    # Filter stderr to suppress Qt D-Bus tray icon noise
    sys.stderr = _StderrFilter(sys.stderr)

    # Run the application with error handling
    try:
        from main import main
        sys.exit(main())
    except ImportError as e:
        logger.error(
            f"Failed to import application: {e}. "
            f"Please verify dependencies are installed correctly."
        )
        sys.exit(1)
    except KeyboardInterrupt:
        logger.info("Application interrupted by user")
        sys.exit(130)
    except Exception as e:
        logger.exception(f"Unexpected error during application startup: {e}")
        sys.exit(1)
