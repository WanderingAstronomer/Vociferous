#!/usr/bin/env python3
"""
Vociferous - Application Entry Point.

This is the bootstrap script that sets up the environment and launches
the main application. It handles GPU library paths before any CUDA
libraries are loaded.

Why a Separate Entry Point?
---------------------------
The main application is in `src/main.py`, but we need this script to:
1. Configure LD_LIBRARY_PATH for GPU libraries
2. Set up Python path to find `src/` modules
3. Configure logging before any other code runs

The key insight is that LD_LIBRARY_PATH must be set BEFORE the process
loads any CUDA/cuDNN libraries. Setting it after import won't work.

Process Re-execution Pattern:
-----------------------------
```
┌─────────────────────────────────────────────────────────────────┐
│  First Execution (LD_LIBRARY_PATH not set)                      │
├─────────────────────────────────────────────────────────────────┤
│  1. Check if NVIDIA libs exist in venv                          │
│  2. Set LD_LIBRARY_PATH with cuDNN + cuBLAS paths               │
│  3. Set sentinel env var _VOCIFEROUS_ENV_READY=1                │
│  4. os.execv() → replaces process with new instance             │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  Second Execution (LD_LIBRARY_PATH set, sentinel present)       │
├─────────────────────────────────────────────────────────────────┤
│  1. Check sentinel → skip re-exec                               │
│  2. Import main (loads CUDA with correct paths)                 │
│  3. Run application                                             │
└─────────────────────────────────────────────────────────────────┘
```

The sentinel prevents infinite re-execution loops.

os.execv() vs subprocess:
-------------------------
`os.execv(executable, args)` REPLACES the current process entirely.
The PID stays the same, but the code is different. This is cleaner
than spawning a subprocess:
- No parent process to manage
- Same PID (for process managers)
- No IPC needed

Path Discovery:
---------------
```python
python_dirs = list(lib_path.glob('python3.*'))
site_packages = python_dirs[0] / 'site-packages' / 'nvidia'
```

NVIDIA installs CUDA libraries into the venv's site-packages. We use
glob to find the Python version directory (3.11, 3.12, etc.) without
hardcoding it.

Why setdefault for CUDA_VISIBLE_DEVICES?
----------------------------------------
```python
os.environ.setdefault('CUDA_VISIBLE_DEVICES', '0')
```

setdefault only sets if not already set. This lets users override
which GPU to use via environment variable while providing a sensible
default (first GPU).

Logging Configuration:
----------------------
Configured BEFORE imports to catch early log messages. Format includes
time, level, logger name, and message for debugging.

Python 3.12+ Features:
----------------------
- Pathlib throughout (no os.path)
- f-strings for path concatenation
- Unpacking in function calls (`*sys.argv`)
"""

import logging
import os
import sys
from pathlib import Path


def _configure_logging() -> None:
    """
    Configure application-wide logging.

    Called before any other code to ensure all log messages are captured.
    Uses a simple console format suitable for development and debugging.

    Format: "HH:MM:SS | LEVEL | logger.name | message"
    """
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
        datefmt="%H:%M:%S",
    )


def _preflight_env() -> None:
    """
    Preflight environment setup for GPU acceleration.

    This function ensures CUDA libraries are discoverable by the dynamic
    linker before any Python code imports them. On Linux, LD_LIBRARY_PATH
    must be set before process start, hence the re-exec pattern.

    The function:
    1. Checks if we've already run (sentinel variable)
    2. Locates NVIDIA CUDA libraries in the venv
    3. If found and not in LD_LIBRARY_PATH, re-execs with correct paths
    4. Sets CUDA_VISIBLE_DEVICES to ensure GPU is available

    Sentinel Pattern:
    -----------------
    `_VOCIFEROUS_ENV_READY` prevents infinite recursion. Without it:
    - Script runs, sets LD_LIBRARY_PATH, execs
    - New process runs, sets LD_LIBRARY_PATH, execs
    - ...forever
    """
    # 1. Enforce Virtual Environment
    # If the venv exists, we MUST use it. This prevents ModuleNotFoundError
    # when dependencies (like sqlalchemy) are installed in venv but script
    # runs via system python.
    venv_path = Path(__file__).parent / ".venv"
    venv_python = venv_path / "bin" / "python3"

    if venv_python.exists():
        # Enforce Venv by checking sys.prefix
        # If we are in the venv, sys.prefix should resolve to the venv directory.
        # If we are in system python, it will be /usr or similar.
        try:
            current_prefix = Path(sys.prefix).resolve()
            expected_prefix = venv_path.resolve()
            
            if current_prefix != expected_prefix:
                # Re-exec args: [python, script, *args]
                os.execv(str(venv_python), [str(venv_python), *sys.argv])
        except Exception as e:
            # Fallback
             logging.getLogger("Vociferous").warning(f"Failed to enforce venv: {e}")
    else:
        logging.getLogger("Vociferous").warning(
            "Virtual environment not found at .venv/. Proceeding with system Python."
        )
        # Create the venv directory variable for later use
        #TODO: venv_path = None

    # Sentinel to prevent infinite re-exec loop
    if os.environ.get("_VOCIFEROUS_ENV_READY") == "1":
        return

    # venv lives at project root (same directory as this script)
    # venv_path is already defined above

    # Find Python version dynamically
    lib_path = venv_path / "lib"
    if not lib_path.exists():
        return

    python_dirs = list(lib_path.glob("python3.*"))
    if not python_dirs:
        return

    site_packages = python_dirs[0] / "site-packages" / "nvidia"
    cudnn_lib = site_packages / "cudnn" / "lib"
    cublas_lib = site_packages / "cublas" / "lib"

    if cudnn_lib.exists() and cublas_lib.exists():
        ld_path = os.environ.get("LD_LIBRARY_PATH", "")
        cudnn_str, cublas_str = str(cudnn_lib), str(cublas_lib)

        if cudnn_str not in ld_path or cublas_str not in ld_path:
            # Re-exec with correct LD_LIBRARY_PATH (must be set before process starts)
            os.environ["LD_LIBRARY_PATH"] = f"{cudnn_str}:{cublas_str}:{ld_path}"
            os.environ["_VOCIFEROUS_ENV_READY"] = "1"
            os.execv(sys.executable, [sys.executable, *sys.argv])

    # Hint CUDA visibility
    os.environ.setdefault("CUDA_VISIBLE_DEVICES", "0")


def _configure_qt_logging_rules() -> None:
    """Set Qt logging rules to quiet expected warnings."""
    rules = os.environ.get("QT_LOGGING_RULES", "")
    desired = [
        "qt.qpa.wayland=false",  # already present to reduce Wayland noise
        "qt.core.io.fs.watchers.warning=false",  # silence QFileSystemWatcher empties
        "qt.qpa.tray=false",  # silence all D-Bus tray icon messages
        "dbus.integration=false",  # silence D-Bus integration warnings
    ]

    for rule in desired:
        if rule not in rules.split(";"):
            rules = f"{rules};{rule}" if rules else rule

    os.environ["QT_LOGGING_RULES"] = rules


class _StderrFilter:
    """Filter stderr to suppress known Qt D-Bus noise."""

    def __init__(self, stream):
        self._stream = stream
        self._suppress_patterns = [
            "QDBusTrayIcon",
            "org.freedesktop.DBus.Error",
        ]

    def write(self, text):
        if not any(pattern in text for pattern in self._suppress_patterns):
            self._stream.write(text)

    def flush(self):
        self._stream.flush()

    def fileno(self):
        return self._stream.fileno()


# Add src to path (src is in the project root, same directory as this script)
sys.path.insert(0, str(Path(__file__).parent / "src"))

if __name__ == "__main__":
    _configure_logging()
    _preflight_env()
    _configure_qt_logging_rules()

    # Filter stderr to suppress Qt D-Bus tray icon noise
    sys.stderr = _StderrFilter(sys.stderr)

    from main import main

    sys.exit(main())
